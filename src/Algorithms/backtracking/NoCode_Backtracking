[What is Backtracking?]

Definition: Backtracking is a recursive problem-solving technique that explores all possible configurations of a solution,
â€œbacktracksâ€ when a partial solution is invalid, and tries alternatives.

Process:
    1. Choose a decision (make a move).

    2. Recurse to explore further.

    3. If the solution is invalid or complete, backtrack (undo the move).

Backtracking is often described as DFS (Depth-First Search) on a decision tree.


[Decision Trees in Backtracking]

Each node = one recursive state.
Each edge = a choice (include/exclude, place/not place, etc.).
Each leaf = a complete solution or a dead end.

Backtracking systematically explores this tree.


[Time Complexity of Backtracking]

To estimate complexity: Timeâ‰ˆ(b) ^ d where b = number of recursive branching per function call | d = worse case depth of the recursive tree

da

Subsets Problem (n elements)

    Branching factor = 2 (include/exclude).
    Depth = n.
    Time: ğ‘‚(2^ğ‘›)

Permutations Problem (n elements)

Branching factor â‰ˆ n (choose 1 of n, then 1 of n-1, etc.).
Depth = n.
Time: ğ‘‚(ğ‘›!)

Combination Sum (target = t, min element = m)

Branching factor = 2 (take/skip).
Depth â‰ˆ t/m (how many times we can add the smallest number).
Time: O(2^t/m)

N-Queens (N x N board)

Branching factor â‰ˆ N (try each column in a row).
Depth = N (one queen per row).
Time: O(N!) in the worst case.


[Space Complexity]
Call stack depth = O(max depth).
Extra space for current solution path = proportional to depth.

Output space (if storing all solutions) can dominate â€” e.g. storing all subsets requires O( (2^n) â‹… n ).

When Formula Doesnâ€™t Apply

Binary Search: not backtracking â€” only explores 1 branch â†’ O(logn).

Dynamic Programming with memoization: avoids exploring duplicate states â†’ complexity = number of unique states Ã— cost per state.

So the exponential formula applies mainly to pure exploration problems (subsets, permutations, N-Queens, Sudoku, etc.).